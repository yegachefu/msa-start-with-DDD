# 5장 마이크로서비스 설계

모듈화의 가치는 아래 두 가지로 인해 얻어진다.

1. 기능적으로 응집성 높게(high cohesion)
2. 기능이 타 모듈 간 의존도를 낮게(low coupling)

마이크로서비스의 설계의 주요 관심사도 이와 같고 내부 구조를 구성하는 요소들도 역할별로 모듈화돼야 한다. 응집성있고 서로 의존성이 낮은 모듈들이 모여 마이크로서비스를 이뤄서 각 요소들이 유연해진다.

이미지 참조 : [https://engineering-skcc.github.io/microservice modeling/microservice-도출기법/](https://engineering-skcc.github.io/microservice%20modeling/microservice-%EB%8F%84%EC%B6%9C%EA%B8%B0%EB%B2%95/) 

## 5.1 마이크로서비스를 도출하는 방법

마이크로서비스가 비즈니스 변화 속도를 지원하면서 독립적으로 변경, 배포되려면 다른 서비스와 의존하지 않아야 하는데 어떤 기준으로 비즈니스를 묶어야 할까?

### 5.1.1 비즈니스 능력에 근거한 도출

마이크로서비스를 식별하는 가장 쉬운 방법은 경험적인 원칙을 적용하는 것이다. 크리스 리처드슨은 비즈니스 능력(capability)에 따라 식별할 수 있다고 했다.

**비즈니스 능력**은 비즈니스 가치를 생산하기 위한 것, 조직이 하는 일이다.

이미 각 도메인에서 비즈니스가 규정하는 일하는 방식, 조직, 부서 체계가 정의돼있을텐데 이처럼 체계적으로 분해하는 것을 **업무 기능 분해**라고 한다. 업무 기능 분해는 업무 흐름에 따라 대, 중, 소의 크기로 분리하고 정렬하면 특정 부서가 처리하는 역할과 비슷해진다. 이를 기반으로 아래와 같이 서비스를 식별할 수 있다.

| 1레벨 | 2레벨 | 3레벨 |
| --- | --- | --- |
| 주문 | 주문 관리 | 주문 처리 |
|  |  | 주문 이력 |
| 배송 | 배송관리 | 배송 이력 |
|  |  | 배송 처리 |
|  |  | 배송업체 관리 |
| 상품 | 상품 관리 | 재고 관리 |
|  |  | 상품 카탈로그  |
| 결제 | 결제 관리 | 결제대행업체 관리 |
|  | 결제 처리 | 카드 결제  |
|  |  | 계좌 이체 |
|  |  | 포인트 결제 |
|  | 포인트 관리 | 포인트 적립 |

위 표와 같이 직관적으로 서비스를 식별한다.

1. 주문 서비스
2. 배송 서비스
3. 상품 서비스
4. 배송업체 관리 서비스
5. 결제 서비스
6. 포인트 서비스

이런 방식은 전체적인 대략의 비즈니스를 이해할 때에는 유용하지만 서비스간 관계나 구체 기능과 연관된 독립적인 데이터를 식별하기에는 미흡하다.

### 5.1.2 DDD의 바운디드 컨텍스트 기반 도출

마이크로서비스는,

1. 각 저장소를 독립적으로 보유
2. 각 데이터는 다른 서비스에서 직접 참조해서는 안됨

이런 특성이 기존 SOA 방식과는 다르게 서비스를 독립적으로 수정, 배포할 수 있는 장점이 된다.

(SOA는 중개 이벤트 버스가 필요하고 하나의 디비만을 사용하기 때문에 독립적으로 수정, 배포가 어렵다!)

```
SOA:서비스 지향 아키텍처(Service Oriented Architecture, 약칭 SOA 「에스오에이」혹은 「소아」로 발음)란 대규모 컴퓨터 시스템을 구축할 때의 개념으로 업무상의 일 처리에 해당하는 소프트웨어 기능을 서비스로 판단하여 그 서비스를 네트워크상에 연동하여 시스템 전체를 구축해 나가는 방법론
ESB(Enterprise Service Bus) 가 서비스에 대한 요청과 처리를 중개하여 인프라 전체 스트럭처에 분포되게 한다.
+ 하나의 디비만을 사용한다.
참조 : https://ko.wikipedia.org/wiki/%EC%84%9C%EB%B9%84%EC%8A%A4_%EC%A7%80%ED%96%A5_%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98
```

따라서 서비스가 소유권을 가진 데이터를 독립적으로 식별하는 것, 즉 서비스가 보유한 기능에 의해서만 접근 가능한(캡슐화) 데이터를 파악해야 하는데

1. 앞서 설명한 기능 분해 방식(대, 중, 소로 나누어 서비스를 식별) 서비스가 소유해야 할 데이터 식별에 적합하지 않고,
2. 기능과 데이터가 분리되고 하나의 통합 데이터가 여러 기능에서 사용되도록 모델링되는 방식이다.

```
(?) 질문.. P 120
기능과 데이터가 분리되고 하나의 통합 데이터가 여러 기능에서 사용되도록 모델링되는 방식이다.
따라서 비즈니스를 처리하는 기능과 그 기능에 영향을 받는 데이터가 분리되는 경향이 있다.
```

그러나 DDD에서는 데이터와 기능을 분리하지 않고 문제 영역인 하위 도메인마다 별도의 도메인 모델로 정의하고 각 업무에 특화된 유비쿼터스 언어로 정의된다.

```
Q. 마이크로서비스는 얼마나 작아야 할까?
전체 업무 맥락에서 질적으로 판단해야 하는데, 자율적으로 수행 가능한 업무의 단위, 개념의 일관성이가 기능의 응집성 등이 기준이 되고
비즈니스 도메인이나 조직의 성숙도에 따라 다르다.
```

## 5.2 DDD에서의 설계

마이크로서비스를 응집성 있게 식별하는 것이 중요한데 DDD의 전략적 설계에서는 **바운디드 컨텍스**라는 단위를 사용할 수 있다. 또, 전략적 설계로 마이크로서비스의 내부 구조도 정의하고 설게할 수 있다.

**바운디드 컨텍스트** : 비즈니스 응집성이 있는 컨텍스트를 구분

## 5.3 DDD의 전략적 설계

전략적 설계를 하면 비즈니스적으로 중요도에 따라 일을 나누기 용이하다. 이에 반드시 알아야할 개념이

1. 도메인 주요 개념 정의하고 경계를 식별하는 바운디드 컨텍스트 
2. 도메인의 모든 구성원이 공통으로 사용하는 유비쿼터스 언어

이다.

### 5.3.1 도메인과 서브도메인

- 도메인 : 하나의 큰 도메인
- 서브 도메인 : 시스템 개발을 통해 해결하고자 하는 비즈니스 도메인을 논리적으로 구분되는 개념으로 나눈 하위 영역 도메인.
    - 핵심 서브도메인: 다른 경쟁자와 차별화를 만들 비즈니스 영역. 우선순위가 높고 전략적으로 큰 투자를 하는 영역
    - 지원 서브도메인: 비즈니스에 필수적이지만 핵심은 아니고 핵심 도메인을 성공시키기 위해 필수적.
    - 일반 서브도메인: 비즈니스적으로 특화된 부분은 아니지만 전체 비즈니스 솔루션엔 필요하고, 기존 제품을 구매해서 대체 가능

예를 들어서, 아마존 쇼핑몰의 경우,

- 핵심 서브도메인 : 추천 영역

쿠팡의 경우

- 핵심 서브도메인 : 로켓배송

### 5.3.2 유비쿼터스 언어와 도메인 모델, 바운디드 컨텍스트

- 유비쿼터스 언어 :
    - 고객이나 현업 담당자가 사용하는 언어와 개발자가 사용하는 기술 언어가 서로 이해를 바탕으로 혼용되어 오해하는 문제를 해결하기 위한 단어/용어사전.
    - 해당 도메인에서의 의도를 명확히 반영하고 핵심 개념을 잘 전달할 수 있는 언어.
    - 작은 단위의 세부 도메인에 특정 업무와 관련된 사람들 간에 자율적으로 정의되고 통용되는 개념.
    - 특정 도메인의 업무 개념을 표현하는 언어.

예를 들어, 결제 도메인의 고객은 결제자를 의미하고 배송 도메인에서의 고객은 수취자를 의미한다. 따라서 명확하게 결제자의 개념, 수취자의 개념으로 모델링해야 의사소통이 명확해진다.

![Untitled](https://github.com/yegachefu/msa-start-with-DDD/blob/main/chapter/images/5_1.png)

- 도메인 모델 :
    - 특정 비즈니스 맥락에서 통용되는 개념들의 관계를 정의한 모형.
    - 도메인 모델로 해당 비즈니스를 이해할 수 있어야 한다.
- 바운디드 컨텍스트 :
    - 도메인 모델을 구성하다 보면 다른 도메인 모델 간 경계가 생기는데 각기 사용하는 언어와 개념이 다른 경계를 도메인 경계
    - 같은 컨텍스트를 다루는 관계자들이 같은 언어를 사용해 설계 산출물, 소스코드에도 사용해야 한다. 이러면 동일한 비전을 공유하고 새로운 팀원이 오더라도 이해하기 용이하다.

### 5.3.3 컨텍스트 매핑

하나의 큰 도메인을 여러 개의 바운디드 컨텍스트로 식별하면 서로 연계해야 하는 경우가 생기는데 이를 컨텍스트 매핑이라고 하고, 연관관계에 있는 두 컨텍스트 사이에 선을 그려서 표현한다.

![Untitled](https://github.com/yegachefu/msa-start-with-DDD/blob/main/chapter/images/5_2.png)

**5.3.3.1 주요 컨텍스트 매핑 관계**

1. 공유 커널(Shared Kernel)

바운디드 컨텍스트 사이에 공통적인 모델을 공유하는 관계. 보통 공통 라이브러리 등이 해당하고, 이 부분이 변경되면 관련 컨텍스트에 영향을 미치므로 모델의 코드 빌드를 관리하는 팀이 별도로 맡는다.

1. 소비자와 공급자(Consumer-Supplier)

공급하는 컨텍스트는 상류(upstream)으로, 소비하는 컨텍스트는 하류(downstream)으로 표시하고 데이터는 상류에서 하류로 흐르기 때문에 공급자는 소비자가 원하는 기능을 제공해야 하고 하류는 상류의 변화를 따라야 한다.

1. 준수자(Confirmist)

소비자와 공급자가 있지만 공급자(상류)가 소비자(하류)의 요구를 지원하지 않거나 못하는 경우 사용한다. 이 경우 소비자는 공급자의 모델을 그대로 사용한다.

1. 충돌 방지 계층(ACL; Anti-Corruption Layer)

하류 팀이 상류 팀의 모델에 영향을 받을 때 하류팀의 고유 모델을 지키기 위해 한 번역 계층을 만들어서 독립성을 유지한다.

보통 클라우드 기반의 마이크로서비스 아키텍쳐를 적용하는 새로운 시스템이 레거시 시스템과 통합하기 위해 사용한다. 새로운 시스템의 기능이 레거시의 기존 기능을 사용하거나 반대의 경우에 사용한다. 예를 들어 REST API 방식을 레거시가 지원하지 않는 경우 레거시를 변경하지 않고 충돌 방지 계층을 구현해서 통신한다.

![Untitled](https://github.com/yegachefu/msa-start-with-DDD/blob/main/chapter/images/5_3.png)

1. 공개 호스트 서비스(OHS; Open Host Service)

바운디드 컨텍스트에 대한 접근을 제공하는 프로토콜이나 인터페이스를 정의해서 하류 컨텍스트가 상위 컨텍스트에서 제공하는 기능을 용이하게 사용할 수 있도록 공개한다.

1. 발행된 언어(PL; Published Language)

XML이나 JSON 스키마로 표현하고 하류가 상류의 기능을 사용하게 할 문서화된 정보 교환 언어이다.

**5.3.3.2 컨텍스트 맵**

하나의 큰 도메인을 여러 바운디드 컨텍스트로 식별하고 관게를 표현한 그림.

![Untitled](https://github.com/yegachefu/msa-start-with-DDD/blob/main/chapter/images/5_4.png)

1. 일반 서브도메인: 공개 호스트 서비스로 프로토콜/인터페이스 제공
2. 핵심 서브도메인: 상류 모델 번역. 일반 서브도메인, 지원 서브도메인 사용 
3. 지원 서브도메인: 핵심 서브도메인에 프로토콜/인터페이스 제공, 일반 서브도메인 사용 

![Untitled](https://github.com/yegachefu/msa-start-with-DDD/blob/main/chapter/images/5_5.png)

1. 회원 컨텍스트에서 인터페이스 제공. 주문 컨텍스트, 배송 컨텍스트가 이를 사용 
2. 상품 컨텍스트에서 인터페이스 제공. 주문 컨텍스트, 배송 컨텍스트가 이를 사용
3. 회원정보가 변경되면 주문 컨텍스트로 비동기 이벤트 발행, 주문 컨텍스트는 배송 컨텍스트로 이벤트 발행
4. 구매완료되면 상품 컨텍스트로 비동기 이벤트 발행

## 5.4 이벤트 스토밍을 통한 마이크로서비스 도출

마이크로서비스의 의존성을 줄이기 위해 서비스 간 비동기 메시지 기반 도메인 이벤트를 활용하는 것이 중요한데 도메인 이벤트를 통한 의존 관계를 식별하는 방법이 쉽지않다. 그래서 알베르토 브란돌리니 라는 사람이 설계 기법을 고안해 냈는데 이것이 이벤트 스토밍이다. 이벤트 중심으로 이해관계자들이 모여 브레인 스토밍을 하는 워크샵을 의미한다.

### 5.4.1 이벤트 스토밍 워크숍 준비

**준비**

1. 공간: 깨끗한 벽이 있는 넓은 공간
2. 참가자: 고객, 도메인 전문가, 설계자, 개발자, 테스트 등 모든 이해관계자
3. 준비물: 벽에 붙일 A0 전지, 마커 펜, 다양한 색의 스티커, 라인 테이프, 스카치 테이프
4. 열린 분위기로 리드하는 퍼실리레이터(facilitator)

**방식**

1. 넓은 공간에 전지를 이어 붙여서 설계 공간을 마련한다
2. 다양한 색의 포스트잇과 준비물을 올려놓는다.
3. 모든 참가자가 마커펜을 든다.
4. 퍼실리레이터의 지시에 따라 워크숍을 진행하고, 타임박싱으로 집중해서 몰입하도록 유도한다.

**스티커 유형별 의미**

| 유형 | 크기/색깔 | 설명 |
| --- | --- | --- |
| 도메인 이벤트 | 오렌지색 | 발생한 사건. 과거 시제 동사로 표현 |
| 커맨드 | 파란색 | 도메인 이벤트를 트리거하는 명령 |
| 외부 시스템 | 핑크색 | 도메인 이벤트가 호출하거나 관계가 있는 레거시 또는 외부 시스템 |
| 액터 | 작은 노란색 | 개인 또는 조직의 역할 |
| 애그리거트 | 노란색 | 도메인 이벤트와 커맨드가 처리하는 데이터. 상태가 변경되는 데이터 |
| 정책 | 라일락색 | 이벤트 조건에 따라 진행되는 결정 when(이벤트) then(커맨드) |
| 읽기모델 | 초록색 | 도메인 이벤트 액터에게 제공되는 데이터 |
| 사용자 인터페이스 | 흰색 | 스케치 형태의 화면 레이아웃 |
| 핫스폿 | 자주색 | 의문. 질문. 미결정 사항 |

### 5.4.2 이벤트 스토밍 워크숍 진행

예시: 상품을 판매하는 사람과 구매하는 사람을 이어주는 쇼핑몰 서비스로서 판매자는 상품을 팔기 위해 상품을 등록하고, 구매자가 주문하면 판매자가 주문한 사람에게 상품을 발송하는 시스템 설계 

1. 도메인 이벤트 찾기
    1. 시간의 흐름에 따라 시스템의 동작을 의미하는 도메인 이벤트를 도출한다. 데이터가 아닌, 비즈니스 흐름에서 발생한 이벤트에 초점을 둔다.
    2. 왼쪽에서 오른쪽으로 시간 흐름순으로 붙이고 연쇄적인 경우 바로 옆에 붙이며 같은 시점에 발생할 수 있는 이벤트는 세로 아래쪽으로 같은 선상에 붙인다.
    3. 도메인 이벤트는 비즈니스의 어떤 상태를 생성, 변경, 삭제하는 요소다. 화면을 연상하지 말고 비스니스의 흐름을 구성하는 요소들의 상태를 생각한다.

![Untitled](https://github.com/yegachefu/msa-start-with-DDD/blob/main/chapter/images/5_6.png)

1. 외부 시스템/외부 프로세스 찾기

레거시나 외부 시스템과의 연계를 통해 업무의 흐름이 진행되는 경우 핑크색 스티커에 명사로 작성한다.

![Untitled](https://github.com/yegachefu/msa-start-with-DDD/blob/main/chapter/images/5_7.png)

1. 커맨드 찾기

도메인 이벤트를 동작하게 하는 커맨드(Command)를 찾고 동사 형태로 작성하고 파란색으로 표현한다.

하나의 커맨드로 여러 이벤트가 동시 또는 연속적으로 발생할 수 있고 조건에 따라 여러 다른 이벤트가 발생할 수 있다.

![Untitled](https://github.com/yegachefu/msa-start-with-DDD/blob/main/chapter/images/5_8.png)

1. 핫스폿 찾기

결정하기 힘든 사항, 의문 사항, 문의가 필요한 사항등을 보라색으로 작성한다.

![Untitled](https://github.com/yegachefu/msa-start-with-DDD/blob/main/chapter/images/5_9.png)

1. 액터(사용자/역할) 찾기

커맨드를 실행하는 사용자, 조직, 역할자. 추상적으로 식별하지 않고 비즈니스를 수행하는 구체적인 역할을 고려해서 명확한 역할자를 도출한다.

액터를 도출하면서 다음처럼 문장을 만들어서 식별한 커맨드와 이벤트를 검토한다.

1. 판매자가 상품을 등록하면 [상품등록됨] 이라는 이벤트를 발생시켜 시스템이 동작한다.
2. 구매자가 상품 주문을 취소하면 [상품 주문 취소됨] 이벤트가 발생하고 재고를 변경하는 [재고변경됨]이벤트가 발생함으로서 시스템이 동작한다.

자연스럽지 않다면 재도출한다. 액터를 식별해서 역할자의 주요 프로세스도 그려볼 수 있다.

![Untitled](https://github.com/yegachefu/msa-start-with-DDD/blob/main/chapter/images/5_10.png)

1. 애그리거트 정의하기
- 애그리거트:
    - 커맨드와 도메인 이벤트가 영향을 주는 데이터 요소. 5.6.1절 ‘DDD의 전술적 설계'의 도메인의 실체 개념을 표현하는 객체인 엔티티가 된다.
    - 애그리거트를 구체적으로 식별하면 컨텍스트 경계를 식별하는데 유용하다.
    - 커맨드와 도메인 이벤트 사이 상단에 겹쳐서 붙인다.

![Untitled](https://github.com/yegachefu/msa-start-with-DDD/blob/main/chapter/images/5_11.png)

1. 바운디드 컨텍스트 정의하기

일부 이름이 같거나 유사한 애그리거트를 완전히 다른 애그리거트와 구분해서 경계를 그린다. 이 경계가 바운디드 컨텍스트이고 애그리거트 이름으로 정의한다. 여러 애그리거트가 있다면 대표 이름을 정한다.

![Untitled](https://github.com/yegachefu/msa-start-with-DDD/blob/main/chapter/images/5_12.png)

1. 정책을 도출하면서 연관관계 생각하기 

라일락색으로 정책을 도출한다. 이벤트 뒤에 따라오는 반응적 비즈니스 로직으로 커맨드를 동작하게 한다.

커맨드는 컨텍스트 안에 있을 수도 있고 다른 컨텍스트에 있을 수 있다.

![Untitled](https://github.com/yegachefu/msa-start-with-DDD/blob/main/chapter/images/5_13.png)

[도메인 이벤트]할 때에는 [정책]으로 인해 항상 [커맨드]한다.

- 구매 바운디드 컨텍스트에서 [구입 완료됨], [결제 취소됨] 이벤트 후 [재고 변경]이라는 정책으로 상품 컨텍스트의[상품 재고 수정] 커맨드를 호출한다.
- 구매 컨텍스트에서 구매가 완료되면 [배송 요청됨] 이라는 이벤트가 발생하고, [배송 생성]이라는 정책으로 인해 배송 컨텍스트의 [배송접수]커맨드를 호출한다.

1. 컨텍스트 매핑하기

컨텍스트 관계를 작성할 땐, 호출할 때 동기 혹은 비동기의 호출 방식을 데이터의 일관성, 컨텍스트의 가용성 면을 고려해서 결정한다. 

- 동기 호출 : 항상 일관된 데이터를 유지해야할 때. 실시간 동시 처리를 위해 호출하고 응답을 대기. 두 컨텍스트 간 의존도가 높다. 실선으로 표현
- 비동기 호출: 컨텍스트 내에서 처리한 후 이벤트를 발행해 연관된 다른 컨텍스트가 이를 받아 처리하는 방식. 실시간 정합성이 필요하지 않는 경우 사용. 독립성과 탄력성이 강화. 점선으로 표현

![Untitled](https://github.com/yegachefu/msa-start-with-DDD/blob/main/chapter/images/5_14.png)

(?) 구매 컨텍스트에서 이메일 시스템 호출은 비동기여도 되지 않을까?

9.1 고객이 클라이언트를 통해 구매 컨텍스트에 동기방식으로 접근한다.

9.2 구매 컨텍스트는 상품의 현재 가격을 가져오기 위해 상품 컨텍스트에 동기 방식으로 접근한다.

9.3 회원 컨텍스트에도 현재 결제 정보와 배송지 정보를 동기 방식으로 가져온다.

9.4 구매 컨텍스트와 배송 컨텍스트는 비동기로 정의해서 배송 컨텍스트에 장애가 발생해도 주문은 정상처리 되도록 한다.

최종적으로 마이크로서비스로 정의하려면 추가로 다음과 같은 질문을 고려한다.

- (비즈니스 측면) 비즈니스 프로세스를 수행하기 위한 하나의 맥락의 단위로 구분될 수 있는가?
- (데이터 관점) 마이크로서비스별로 분리된 데이터를 정의할 수 있는가?
- (운영 조직 측면) 하나의 팀이 독립적으로 운영 가능한 단위인가?
- (배포 측면) 독립적으로 배포 가능한 단위인가?
- (변경 영향도) 변경 시 영향을 받는 마이크로서비스가 존재하는가?
- (클라우드/MSA 도입 목적 측면) 도입을 통한 기대효과를 충분히 활용할 수 있는가?

1. 마이크로서비스 상세 설계를 위한 입력물

이벤트 스토밍 결과로 프론트엔드, 백엔드 모델링에 활용한다.

## 5.5 마이크로서비스 상세설계

마이크로서비스는 프론트엔드와 백엔드로 나뉘어 개발되고 배포되며 모두 설계, 구현되어야 한다. 이 책에선 백엔드를 위주로 설명한다.

### 5.5.1 프론트엔드 모델링

사용자 경험에 민감하게 반응할 수 있는 UI 기술과 개념이 등장했고 SPA(Single-Page Application)을 잘 지원하는 앵귤러, 리액트, 뷰 등의 프레임워크가 등장했다.

프론트엔드의 최소한의 설계 영역은 아래와 같다.

1. 프론트 아키텍쳐 정의 

모바일, 웹, 앱 모든 채널의 사용자 경험에 민감하게 반응하는 반응형 UI 를 지향하고 있고, 최근에는 리액트와 뷰를 많이 사용한다. 이는 컴포넌트 구조의 재사용 가능한 구조를 지원한다. 

X-Internet이라고 하는 RIA(Rich Internet Application. 웹 앱의 장점을 유지하면서 늦은 응답 속도, 데스크탑 앱에 비해 떨어지는 조작성을 개선하는 기술의 통칭)를 사용하기도 하는데 REST API 형식을 온전히 지원하지 않는 경우도 있어서 검토할 필요가 있다.

백엔드 API 와 연계되는 스파이크 솔루션을 통해 아키텍쳐가 사용자 요건을 만족하는지 검토할 필요가 있다.

- (eXtreme Programming 방법론에서 나온 용어로, 문제 영역을 해결하기 위해 실제로 간단히 구현해보는 프로그램)
1. 표준 레이아웃 정의

CRUD의 대표적인 업무 화면 유형을 먼저 정의하고 사용자 경험을 검토한다. 

1. UI 레이아웃 설계

개별 UI 레이아웃을 정의. 각 기능을 만족할 UI를 정의하는데 기능을 수행할 버튼 등을 정의한다. 흐름을 보여주는 문서를 만들기도 하는데 이를 UI 스토리보드라고 한다.

1. UI 디자인 및 UI 레이아웃 반영

보통 웹디자이너가 수행하며 화면 유형에 맞는 UI 디자인을 정의한다. 프론트엔드 개발자는 디자이너의 디자인 의도를 반영해 디자인을 적용한다.

1. 이벤트 설계 

화면의 이벤트 변화에 따라 백엔드 API 를 호출하는 방식을 정의

### 5.5.2 백엔드 모델링

헥사고날 아키텍처를 적용해 외부 영역과 내부 영역으로 나누어 진행한다.

1. 커맨드: 헥사고날 인바운드 어댑터의 하나인 REST API 가 됨
2. 애그리거트: 헥사고날 내부영역인 도메인 모델.
3. 도메인 이벤트: 헥사고날 외부 영역의 아웃바운드 메시지 처리 어댑터의 처리 대상
4. 외부 시스템: 아웃바운드 어댑터가 호출해야 할 외부 연계 시스템

![Untitled](https://github.com/yegachefu/msa-start-with-DDD/blob/main/chapter/images/5_15.png)

1. 커맨드 [주문항목검색], [주문아이템주문], [상품주문취소]는 클라이언트나 외부 서비스에서 접근할 REST API 로 매핑
2. 회원 서비스와 상품 서비스는 REST API 로 연계하고 
3. 정책 [재고변경]은 비동기를 위해 메시지 브로커로 매핑 
4. 애그리거트 [상품], [결제]는 도메인 모델에 매핑되어 디비에서 관리

외부 영역 설계는 프론트엔드와 연계되는 ‘API 설계', 내부 영역은 ‘도메인 모델링’, ‘데이터 모델링'으로 구체화된다.

**5.5.2.1 API 설계**

헥사고날 인바운드 어댑터로서 어떠한 호출 방식도 허용되지만 최근엔 HTTP 프로토콜, JSON 포맷을 사용하는 REST API가 표준처럼 사용된다.

- REST API 의 개념

자원(resource), 행위(verb), 표현(representation) 으로 아키텍쳐를 표현한다.

자원 : URI

행위: HTTP 메소드

표현: JSON 형태의 문서

```
HTTP POST http://example.com/users
{
	"users": {
		"name": "홍길동"
	}
}
```

- REST API 성숙도
    - 레벨 0: REST API 메커니즘을 전혀 사용하지 않고 전통적인 원격 프로시저 호출 방식으로 HTTP 프로토콜만 사용한다. (/ProductService?Flag=create) 처럼 하나의 URI 주소에 flag를 사용해 입력, 수정, 삭제를 수행한다. 따라서 API 명세가 필요하다.
    - 레벨 1: URI 에 개별적인 자원을 표현. 여러 기능을 사용하기 위해 요청이 필요한 대상을 특정한다. 특정 리소스가 어떤 정보를 제공하는지 인지할 수 있다.
    - 레벨 2: HTTP 의 메소드를 사용해서 GET(조회), POST(추가), PUT(수정), DELETE(삭제)로 처리한다.
    - 레벨 3: HATEOAS(Hypertext As The Engine Of Application State) 를 사용해서 반환값에 기대했던 응답 + 사용자가 그 다음에 무엇을 할 수 있고 그걸 하기 위한 URI 를 반환한다.
- API 설계 문서화
    - 간단히 위키 형태의 문서로 작성한다.
        - 서비스명, API 명, 리소스(URI)
        - 요청 매개변수, 요청 샘플
        - 응답 매개변수, 응답 샘플

## 5.6 도메인 모델링

마이크로서비스의 내부 구조는 폴리글랏하게 접근할 수 있다. 애플리케이션을 구현하는 언어나 데이터베이스를 서비스마다 다양하게 활용할 수 있다. 따라서 내부 구조를 도메인 모델 중심으로 만들 수도 있고, 트랜잭션 스크립트 형태로 만들 수 있다.

- 트랜잭션 스크립트 구조: DTO 는 데이터 묶음으로서의 역할만 수행하고 서비스가 많은 로직을 보유하게 되어 시스템이 복잡해질 수 있다. 단순한 로직이면 괜찮지만 비즈니스가 복잡해질 수록 도메인 모델 구조가 효과적이다.
- 도메인 모델 구조: 도메인 모델 중심의 구조. 서비스가 모든 로직을 처리하지않고 비즈니스 로직이 도메인 모델로 위임되어 적절히 분산된다.

### 5.6.1 DDD의 전술적 설계(도메인 모델링 구성요소)

기존 객체 모델링 방식은 자유도가 높아 여러 복잡한 계층 구조를 만들 가능성이 높아지는데, DDD 전술적 설계는  객체들의 역할에 따른 유형을 정의하고 모델링해서 단순하고 이해하기 좋아진다.

도메인 모델을 구성하는 객체 구성 요소를 살펴본다.

1. 엔티티: 다른 엔티티와 구별할 수 있는 식별자를 가진 도메인의 실체 개념을 표현한 객체. 식별자는 고유하지만 엔티티의 상태는 계속 변할 수 있다.
2. 값 객체(Value Object): 각 속성이 개별적으로 변화하지 않는 개념적 완전성을 모델링해서 객체 전체가 한 번에 생성되거나 삭제되는 객체다. 속성과 속성으로 이뤄진 값의 비교에 의해 동일함이 결정된다.
    1. 도메인 내의 어떤 대상을 측정하고 수량화하고 설명한다.
    2. 관련 특징을 모든 필수 단위로 개념적 전체를 모델링한다.
    3. 측정이나 설명이 변경될 땐 완벽히 대체 가능하다.
    4. 다른 값과 등가성을 사용해 비교할 수 있다.
    5. 값 객체는 일단 생성되면 변경할 수 없다.

(J2EE에서 Value Object(Transfer Object) 패턴과는 다르며, 이 경우는 DTO(Data Transfer Object) 가 더 적절하다. )

![Untitled](https://github.com/yegachefu/msa-start-with-DDD/blob/main/chapter/images/5_16.png)

1. 표준 타입: 대상의 타입을 나타내는 서술적 객체. 엔티티나 값 객체의 속성을 구분하는 용도로 사용된다. 주로 자바에서는 ENUM 으로 정의한다.
2. 애그리거트: 객체 간 계층 구조가 만들어지는데 연관된 엔티티와 값 객체들의 묶음. 
    1. 1~2개의 엔티티, 값 객체, 표준타입으로 구성되고 
    2. 이들 간 의존관계를 맺고 있으며 비즈니스 정합정을 맞출 필요가 있다.
    3. 애그리거트 단위가 트랜잭션의 기본 단위가 된다.
    4. 가장 상위의 엔티티를 애그리거트 루트로 정하고 애그리거트 루트를 통해서만 애그리거트 내의 엔티티나 값 객체를 변경할 수 있다. 
    5. 하나의 컨텍스트 안에 하나 이상의 애그리거트가 존재할 수 있고, 루트의 식별자를 통해 참조한다.
    6. 애그리거트가 별도의 마이크로서비스의 후보가 될 수 있다.
    7. 각 애그리거트는 각 단일 트랜잭션으로 일관성을 유지하고, 다른 애그리거트와의 일관성이 필요하다면 도메인 이벤트를 통해 결과적 일관성을 사용한다.
3. 도메인 서비스: 비즈니스 로직 처리가 특정 엔티티가 VO 에 속하지 않을 때 단독 객체를 만들어서 처리한다. 상태를 관리하지 않고 행위만 존재하며 상태를 엔티티가 VO 에 전달한다.
4. 도메인 이벤트: DDD, 이벤트 스토밍에서 말하는 도메인 이벤트의 구현 객체. 서비스 간 정합성을 일치시키기 위해 단위 애그리거트의 주요 상태값을 담아 전달하도록 모델링한다. 이벤트 발행은 발행한 서비스의 트랜잭션과 묶어서 실행되어야 한다.

## 5.7 정리

1. 마이크로서비스 도출
    1. 비즈니스 능력 기반
    2. DDD의 바운디드 컨텍스트 기반
        1. DDD 전략적 설계 개념 및 구성 요소
        2. 이벤트 스토밍 
2. 마이크로서비스 상세 설계
    1. 프론트엔드 설계 고려사항
    2. 백엔드 설계
        1. 도메인 모델링
